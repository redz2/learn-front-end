# 事件循环
## 浏览器的进程模型
* 何为进程？（给你分配一个房子）
* 何为线程？（给你几个工人）
* 浏览器有哪些进程？
    1. 浏览器进程
    2. 网络进程
    3. 渲染进程（创建一个渲染主线程，负责执行html/css/js代码）【沙盒】安全

## 渲染主线程是如何工作的
为什么渲染主线程不适用多个线程来处理这些事情？
解析html
解析css
执行js
每秒画60次

如何调度任务？
比如正在执行js代码，执行到一半用户点击了按钮，我该立即去执行点击事件的回调函数吗？（需要排队）

渲染主线程每次执行一个任务（任务队列中不断添加任务）

## 若干解释
1. 何为异步？
JS是一门单线程的语言，因为他运行在浏览器的渲染主线程中。而主渲染线程不能被阻塞，如果采用同步，会造成主线程时间白白浪费，页面无法及时更新。浏览器只能采用异步的方式
因为是单线程，所以需要解决阻塞的问题，所以需要采用异步的方式

一些无法立即执行的任务(有个计时线程在拿着表看，到时间后放入队列中)
setTimeout、setInterval、addEventsListener

2. JS为何会阻碍渲染？
绘制页面也是一个任务（因为JS和渲染都在一个渲染主线程上）

3. 任务有优先级吗？
任务没有优先级，先进先出！！！
但是，队列是有优先级的！！！不同的任务放在不同的队列中

渲染主线程（全局一定会先执行）
延时队列（中）
交互队列（高，用户点击事件）
微队列（优先级最高：用户自己存放到队列，使用Promise）

setTimeout(function(){
    console.log(1)
})
Promise.resolve().then(function(){
    console.log(2)
})
console.log(3)

结果：3 2 1

4. JS计时器有偏差吗？
* 计算机没有原子时钟，有偏差
* 操作系统计时函数本身就有偏差
* 受事件循环影响，计时器的回调函数只能在渲染主线程空闲时执行，因此也有偏差（浏览器也认为延时队列多等2秒没什么关系）



# 浏览器渲染原理
## 渲染时间点
HTML字符串 --渲染--> 像素点

function render(html){
    <!-- 第一行：第一个像素点，第二个像素点 -->
    <!-- 第二行... -->
}

### 渲染主线程
1. 解析HTML（parse）
会生成DOM树、CSSOM树，遇到JS会执行JS

2. 样式计算（style）
DOM树和CSSOM树会交给样式计算

3. 布局（layout）
生成几何信息

内容必须在行盒中(a和c边上会有匿名行盒)
行盒和块盒不能相邻的(b边上会有匿名块盒)
```
<p>a</p>
b
<p>c</p>
```

4. 分层
和堆叠上下文有关的属性（zindex、opacity、transform）会影响分层的结果（不会决定如何分层）
will-change: transform; (你只能给浏览器提供建议，至于最后如何分层，浏览器自己会决定)

5. 绘制
将笔移动到10,30位置，画一个200*300的矩形，用红色填充矩形（有点像canvas？？？功能就是借鉴浏览器）

### 合成线程
6. 分块（Tiling）
分块会将每一层分为多个小的区域

7. 光栅化（Raster）
光栅化是将每个块变成位图（此过程会使用GPU）
优先处理靠紧视口的块

8. 画（Draw）
相对屏幕在哪里（transform效率高，因为旋转、缩放、等变形发生在合成线程，与渲染主线程无关）

什么是reflow？
dom.style.width = ?
等JS执行完后，一堆信息改变后，重新绘制（如果有读取width的代码怎么办）

什么是repaint?

为什么transform效率高？
transform: translateX(200px)
left: 200px;
渲染主线程: parse---style---layout---layer---paint
合成线程:                                         ---tiling---raster---draw